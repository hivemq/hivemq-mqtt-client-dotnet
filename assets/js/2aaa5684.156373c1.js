"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[847],{6222(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"how-to/manual-ack","title":"Manual Acknowledgement of Incoming Publishes","description":"The ability to manually acknowledge incoming publishes was added in v0.40.0.","source":"@site/docs/how-to/manual-ack.md","sourceDirName":"how-to","slug":"/how-to/manual-ack","permalink":"/hivemq-mqtt-client-dotnet/docs/how-to/manual-ack","draft":false,"unlisted":false,"editUrl":"https://github.com/hivemq/hivemq-mqtt-client-dotnet/tree/main/Documentation/docs/how-to/manual-ack.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"docsSidebar","previous":{"title":"Configure a Proxy Server","permalink":"/hivemq-mqtt-client-dotnet/docs/how-to/configure-proxy"},"next":{"title":"Reference","permalink":"/hivemq-mqtt-client-dotnet/docs/category/reference"}}');var l=i(4848),c=i(8453);const t={sidebar_position:9},a="Manual Acknowledgement of Incoming Publishes",o={},r=[{value:"Enabling manual ack",id:"enabling-manual-ack",level:2},{value:"Acknowledging messages",id:"acknowledging-messages",level:2},{value:"By packet identifier",id:"by-packet-identifier",level:3},{value:"By event args (recommended when mixing QoS levels)",id:"by-event-args-recommended-when-mixing-qos-levels",level:3},{value:"QoS behavior",id:"qos-behavior",level:2},{value:"Receive Maximum and unacked messages",id:"receive-maximum-and-unacked-messages",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Thread safety",id:"thread-safety",level:2},{value:"Full example (HiveMQClient)",id:"full-example-hivemqclient",level:2},{value:"RawClient",id:"rawclient",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"manual-acknowledgement-of-incoming-publishes",children:"Manual Acknowledgement of Incoming Publishes"})}),"\n",(0,l.jsx)(n.admonition,{title:"Version Note",type:"info",children:(0,l.jsxs)(n.p,{children:["The ability to manually acknowledge incoming publishes was added in ",(0,l.jsx)(n.strong,{children:"v0.40.0"}),"."]})}),"\n",(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.strong,{children:"manual ack"})," is enabled, the client does not send PubAck (QoS 1) or PubRec (QoS 2) to the broker until your application explicitly acknowledges each received message. This gives you control over when the broker considers a message delivered\u2014for example, after persisting it or completing business logic."]}),"\n",(0,l.jsx)(n.admonition,{title:"When to use manual ack",type:"info",children:(0,l.jsxs)(n.p,{children:["Use manual ack when you need to process or store messages before the broker is told they were received. Unacknowledged messages consume slots in the ",(0,l.jsx)(n.a,{href:"https://www.hivemq.com/blog/mqtt5-essentials-part12-flow-control/",children:"Receive Maximum"})," window until you call ",(0,l.jsx)(n.code,{children:"AckAsync"})," or the connection closes."]})}),"\n",(0,l.jsx)(n.h2,{id:"enabling-manual-ack",children:"Enabling manual ack"}),"\n",(0,l.jsx)(n.p,{children:"Enable manual acknowledgement when building client options:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'using HiveMQtt.Client;\n\nvar options = new HiveMQClientOptionsBuilder()\n    .WithBroker("broker.example.com")\n    .WithPort(1883)\n    .WithManualAck()   // or .WithManualAck(true)\n    .Build();\n\nvar client = new HiveMQClient(options);\nawait client.ConnectAsync();\n'})}),"\n",(0,l.jsxs)(n.p,{children:["To disable (default): ",(0,l.jsx)(n.code,{children:".WithManualAck(false)"})," or omit the call."]}),"\n",(0,l.jsx)(n.h2,{id:"acknowledging-messages",children:"Acknowledging messages"}),"\n",(0,l.jsxs)(n.p,{children:["Two overloads are available on both ",(0,l.jsx)(n.code,{children:"IHiveMQClient"})," and ",(0,l.jsx)(n.code,{children:"IRawClient"}),":"]}),"\n",(0,l.jsx)(n.h3,{id:"by-packet-identifier",children:"By packet identifier"}),"\n",(0,l.jsx)(n.p,{children:"For QoS 1 and QoS 2, each received publish has a packet identifier. Use it to acknowledge:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"client.OnMessageReceived += (sender, args) =>\n{\n    // Only QoS 1 and 2 have a packet identifier\n    if (args.PacketIdentifier.HasValue)\n    {\n        _ = client.AckAsync(args.PacketIdentifier.Value);\n    }\n};\n"})}),"\n",(0,l.jsx)(n.h3,{id:"by-event-args-recommended-when-mixing-qos-levels",children:"By event args (recommended when mixing QoS levels)"}),"\n",(0,l.jsx)(n.p,{children:"When your subscription receives both QoS 0 and QoS 1/2, use the event-args overload. It no-ops for QoS 0 (no packet identifier) and acknowledges for QoS 1 and 2:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"client.OnMessageReceived += async (sender, args) =>\n{\n    // Process the message (e.g. persist, forward)...\n    await ProcessMessageAsync(args.PublishMessage);\n\n    // Safe for any QoS: no-op for QoS 0, sends PubAck/PubRec for QoS 1/2\n    await client.AckAsync(args);\n};\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This avoids having to check ",(0,l.jsx)(n.code,{children:"PacketIdentifier"})," and prevents accidentally using it when it is null (QoS 0)."]}),"\n",(0,l.jsx)(n.h2,{id:"qos-behavior",children:"QoS behavior"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"QoS"}),(0,l.jsx)(n.th,{children:"Packet identifier"}),(0,l.jsx)(n.th,{children:"Manual ack behavior"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"0"})}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"null"})}),(0,l.jsxs)(n.td,{children:["No ack is sent. ",(0,l.jsx)(n.code,{children:"AckAsync(args)"})," is a no-op."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"1"})}),(0,l.jsx)(n.td,{children:"Set"}),(0,l.jsxs)(n.td,{children:["Call ",(0,l.jsx)(n.code,{children:"AckAsync"})," to send PubAck to the broker."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"2"})}),(0,l.jsx)(n.td,{children:"Set"}),(0,l.jsxs)(n.td,{children:["Call ",(0,l.jsx)(n.code,{children:"AckAsync"})," to send PubRec; client completes QoS 2 flow when broker sends PubRel."]})]})]})]}),"\n",(0,l.jsxs)(n.p,{children:["For QoS 0, ",(0,l.jsx)(n.code,{children:"OnMessageReceivedEventArgs.PacketIdentifier"})," is always ",(0,l.jsx)(n.code,{children:"null"}),". The client does not send any acknowledgement to the broker for QoS 0."]}),"\n",(0,l.jsx)(n.h2,{id:"receive-maximum-and-unacked-messages",children:"Receive Maximum and unacked messages"}),"\n",(0,l.jsxs)(n.p,{children:["The broker limits how many QoS 1 and QoS 2 publishes can be \u201cin flight\u201d to the client (Receive Maximum). With manual ack enabled, each message you have not yet acknowledged consumes one of those slots. If you receive more messages than the window size without acknowledging, the broker will stop delivering until you call ",(0,l.jsx)(n.code,{children:"AckAsync"})," (or disconnect). Configure a larger window if you need more in-flight messages:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var options = new HiveMQClientOptionsBuilder()\n    .WithBroker("broker.example.com")\n    .WithManualAck()\n    .WithReceiveMaximum(100)   // Allow more unacked messages\n    .Build();\n'})}),"\n",(0,l.jsx)(n.h2,{id:"exceptions",children:"Exceptions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Manual ack not enabled:"})," Calling ",(0,l.jsx)(n.code,{children:"AckAsync"})," when ",(0,l.jsx)(n.code,{children:"ManualAckEnabled"})," is ",(0,l.jsx)(n.code,{children:"false"})," throws ",(0,l.jsx)(n.code,{children:"HiveMQttClientException"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Invalid packet identifier:"})," If no pending incoming publish exists for the given packet id (e.g. wrong id or already acked), ",(0,l.jsx)(n.code,{children:"AckAsync"})," throws ",(0,l.jsx)(n.code,{children:"HiveMQttClientException"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Double ack:"})," Acknowledging the same packet identifier more than once throws ",(0,l.jsx)(n.code,{children:"HiveMQttClientException"})," (e.g. \u201cPacket identifier X was already acknowledged.\u201d)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Not connected:"})," Calling ",(0,l.jsx)(n.code,{children:"AckAsync"})," when the client is not connected throws ",(0,l.jsx)(n.code,{children:"HiveMQttClientException"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Null event args:"})," ",(0,l.jsx)(n.code,{children:"AckAsync(OnMessageReceivedEventArgs eventArgs)"})," throws ",(0,l.jsx)(n.code,{children:"ArgumentNullException"})," if ",(0,l.jsx)(n.code,{children:"eventArgs"})," is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"thread-safety",children:"Thread safety"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"AckAsync"})," may be called from any thread, including directly from your ",(0,l.jsx)(n.code,{children:"OnMessageReceived"})," handler (which may run on a thread-pool thread). You do not need to marshal the call back to a specific thread."]}),"\n",(0,l.jsx)(n.h2,{id:"full-example-hivemqclient",children:"Full example (HiveMQClient)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'using HiveMQtt.Client;\nusing HiveMQtt.MQTT5.Types;\n\nvar options = new HiveMQClientOptionsBuilder()\n    .WithBroker("broker.example.com")\n    .WithPort(1883)\n    .WithManualAck()\n    .Build();\n\nvar client = new HiveMQClient(options);\nclient.OnMessageReceived += async (sender, args) =>\n{\n    try\n    {\n        // Your processing (e.g. save to DB, forward)\n        await SaveToDatabaseAsync(args.PublishMessage);\n    }\n    finally\n    {\n        // Always ack when manual ack is enabled (no-op for QoS 0)\n        await client.AckAsync(args);\n    }\n};\n\nawait client.ConnectAsync();\nawait client.SubscribeAsync("orders/#", QualityOfService.AtLeastOnceDelivery);\n'})}),"\n",(0,l.jsx)(n.h2,{id:"rawclient",children:"RawClient"}),"\n",(0,l.jsxs)(n.p,{children:["Manual ack works the same with ",(0,l.jsx)(n.code,{children:"RawClient"}),": enable with ",(0,l.jsx)(n.code,{children:"WithManualAck()"})," and use ",(0,l.jsx)(n.code,{children:"AckAsync(packetIdentifier)"})," or ",(0,l.jsx)(n.code,{children:"AckAsync(eventArgs)"})," on the ",(0,l.jsx)(n.code,{children:"RawClient"})," instance. Use the packet identifier from your receive path (e.g. from the publish packet or from higher-level event args if you build them)."]}),"\n",(0,l.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/reference/client_options",children:"HiveMQClientOptions Reference"})," \u2014 ",(0,l.jsx)(n.code,{children:"ManualAckEnabled"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/reference/client_options_builder",children:"HiveMQClientOptionsBuilder Reference"})," \u2014 ",(0,l.jsx)(n.code,{children:"WithManualAck"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/events",children:"Lifecycle Events"})," \u2014 ",(0,l.jsx)(n.code,{children:"OnMessageReceived"})," and event args"]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://www.hivemq.com/blog/mqtt5-essentials-part12-flow-control/",children:"MQTT 5 Essentials \u2013 Receive Maximum"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>t,x:()=>a});var s=i(6540);const l={},c=s.createContext(l);function t(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);
"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[7297],{7565(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rawclient","title":"RawClient (Beta)","description":"The RawClient is currently in beta. While fully functional, the API may change in future releases based on feedback. We encourage you to try it out and share your experiences.","source":"@site/docs/rawclient.md","sourceDirName":".","slug":"/rawclient","permalink":"/hivemq-mqtt-client-dotnet/docs/rawclient","draft":false,"unlisted":false,"editUrl":"https://github.com/hivemq/hivemq-mqtt-client-dotnet/tree/main/Documentation/docs/rawclient.md","tags":[],"version":"current","sidebarPosition":25,"frontMatter":{"sidebar_position":25},"sidebar":"docsSidebar","previous":{"title":"HiveMQClient","permalink":"/hivemq-mqtt-client-dotnet/docs/hivemqclient"},"next":{"title":"Security Best Practices","permalink":"/hivemq-mqtt-client-dotnet/docs/security"}}');var t=i(4848),c=i(8453);const r={sidebar_position:25},l="RawClient (Beta)",a={},o=[{value:"Overview",id:"overview",level:2},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"When to Use RawClient",id:"when-to-use-rawclient",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Connecting",id:"connecting",level:2},{value:"With Default Options",id:"with-default-options",level:3},{value:"With Specific Options",id:"with-specific-options",level:3},{value:"With Connect Options Override",id:"with-connect-options-override",level:3},{value:"Publishing Messages",id:"publishing-messages",level:2},{value:"Simple Publish",id:"simple-publish",level:3},{value:"With MQTT5PublishMessage",id:"with-mqtt5publishmessage",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Subscribing to Topics",id:"subscribing-to-topics",level:2},{value:"Simple Subscribe",id:"simple-subscribe",level:3},{value:"With SubscribeOptions",id:"with-subscribeoptions",level:3},{value:"Receiving Messages",id:"receiving-messages",level:2},{value:"Global Message Handler",id:"global-message-handler",level:3},{value:"Implementing Custom Message Routing",id:"implementing-custom-message-routing",level:3},{value:"Unsubscribing",id:"unsubscribing",level:2},{value:"Disconnecting",id:"disconnecting",level:2},{value:"Events",id:"events",level:2},{value:"Lifecycle Events",id:"lifecycle-events",level:3},{value:"Packet-Level Events",id:"packet-level-events",level:3},{value:"LocalStore",id:"localstore",level:2},{value:"Resource Cleanup",id:"resource-cleanup",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rawclient-beta",children:"RawClient (Beta)"})}),"\n",(0,t.jsx)(n.admonition,{title:"Beta Feature",type:"caution",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," is currently in ",(0,t.jsx)(n.strong,{children:"beta"}),". While fully functional, the API may change in future releases based on feedback. We encourage you to try it out and share your experiences."]})}),"\n",(0,t.jsxs)(n.admonition,{title:"Version Requirement",type:"info",children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," was introduced in ",(0,t.jsx)(n.strong,{children:"v0.37.0"}),". Make sure you have the latest ",(0,t.jsx)(n.a,{href:"https://www.nuget.org/packages/HiveMQtt",children:"HiveMQtt NuGet package"})," installed:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"dotnet add package HiveMQtt\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," is a low-level, performance-oriented MQTT 5.0 client that provides direct access to the MQTT protocol without the subscription management features found in the standard ",(0,t.jsx)(n.code,{children:"HiveMQClient"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"RawClient"}),(0,t.jsx)(n.th,{children:"HiveMQClient"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Subscription state tracking"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Per-subscription callbacks"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"client.Subscriptions"})," property"]}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Message routing by subscription"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Performance optimized"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Standard"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory footprint"}),(0,t.jsx)(n.td,{children:"Lower"}),(0,t.jsx)(n.td,{children:"Standard"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-rawclient",children:"When to Use RawClient"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," is ideal for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High-throughput scenarios"})," where minimal overhead is critical"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simple publish-only applications"})," that don't need subscription management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom subscription handling"})," where you want full control over message routing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Embedded or resource-constrained environments"})," where memory is limited"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Protocol-level debugging"})," and testing"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For most applications, we recommend using the standard ",(0,t.jsx)(n.code,{children:"HiveMQClient"})," which provides subscription tracking, per-subscription callbacks, and a more feature-rich experience."]}),"\n",(0,t.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using HiveMQtt.Client;\nusing HiveMQtt.MQTT5.Types;\n\n// Create a RawClient\nvar client = new RawClient();\n\n// Setup a global message handler BEFORE connecting\nclient.OnMessageReceived += (sender, args) =>\n{\n    Console.WriteLine($"Message received on {args.PublishMessage.Topic}: {args.PublishMessage.PayloadAsString}");\n};\n\n// Connect to the broker\nvar connectResult = await client.ConnectAsync().ConfigureAwait(false);\n\n// Subscribe to a topic (RawClient does NOT track this subscription)\nawait client.SubscribeAsync("my/topic", QualityOfService.AtLeastOnceDelivery).ConfigureAwait(false);\n\n// Publish a message\nawait client.PublishAsync("my/topic", "Hello from RawClient!").ConfigureAwait(false);\n\n// Disconnect when done\nawait client.DisconnectAsync().ConfigureAwait(false);\nclient.Dispose();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"connecting",children:"Connecting"}),"\n",(0,t.jsx)(n.h3,{id:"with-default-options",children:"With Default Options"}),"\n",(0,t.jsxs)(n.p,{children:["Without any options, the ",(0,t.jsx)(n.code,{children:"RawClient"})," will attempt to connect to ",(0,t.jsx)(n.code,{children:"localhost"})," on port 1883."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using HiveMQtt.Client;\n\nvar client = new RawClient();\nvar connectResult = await client.ConnectAsync().ConfigureAwait(false);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"with-specific-options",children:"With Specific Options"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"HiveMQClientOptionsBuilder"})," to configure the client (same as ",(0,t.jsx)(n.code,{children:"HiveMQClient"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var options = new HiveMQClientOptionsBuilder()\n    .WithBroker("broker.hivemq.com")\n    .WithPort(8883)\n    .WithUseTls(true)\n    .WithClientId("my-raw-client")\n    .Build();\n\nvar client = new RawClient(options);\nvar connectResult = await client.ConnectAsync().ConfigureAwait(false);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"with-connect-options-override",children:"With Connect Options Override"}),"\n",(0,t.jsx)(n.p,{children:"You can override certain options at connect time:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var client = new RawClient(options);\n\nvar connectOptions = new ConnectOptions\n{\n    KeepAlive = 120,\n    SessionExpiryInterval = 600,\n    CleanStart = false,\n};\n\nvar connectResult = await client.ConnectAsync(connectOptions).ConfigureAwait(false);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"publishing-messages",children:"Publishing Messages"}),"\n",(0,t.jsx)(n.h3,{id:"simple-publish",children:"Simple Publish"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Publish with string payload (default QoS 0)\nvar result = await client.PublishAsync("topic/example", "Hello World!").ConfigureAwait(false);\n\n// Publish with specific QoS\nvar result = await client.PublishAsync("topic/example", "Hello World!", QualityOfService.AtLeastOnceDelivery).ConfigureAwait(false);\n\n// Publish with byte array payload\nvar payload = Encoding.UTF8.GetBytes("Binary payload");\nvar result = await client.PublishAsync("topic/example", payload, QualityOfService.ExactlyOnceDelivery).ConfigureAwait(false);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"with-mqtt5publishmessage",children:"With MQTT5PublishMessage"}),"\n",(0,t.jsx)(n.p,{children:"For full control over the publish message:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var message = new MQTT5PublishMessage\n{\n    Topic = "topic/example",\n    Payload = Encoding.UTF8.GetBytes("Advanced message"),\n    QoS = QualityOfService.AtLeastOnceDelivery,\n    Retain = true,\n    ContentType = "application/json",\n    ResponseTopic = "response/topic",\n};\n\nmessage.UserProperties.Add("Client-Geo", "-33.8688, 151.2093");\n\nvar result = await client.PublishAsync(message).ConfigureAwait(false);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," includes a fast path for simple QoS 0 messages. When publishing QoS 0 messages without topic aliases or retain flags, the client skips validation overhead for maximum performance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// This takes the fast path - minimal overhead\nvar message = new MQTT5PublishMessage\n{\n    Topic = "sensor/data",\n    Payload = sensorData,\n    QoS = QualityOfService.AtMostOnceDelivery,\n};\n\nvar result = await client.PublishAsync(message).ConfigureAwait(false);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"subscribing-to-topics",children:"Subscribing to Topics"}),"\n",(0,t.jsx)(n.admonition,{title:"Important Difference",type:"warning",children:(0,t.jsxs)(n.p,{children:["Unlike ",(0,t.jsx)(n.code,{children:"HiveMQClient"}),", the ",(0,t.jsx)(n.code,{children:"RawClient"})," does ",(0,t.jsx)(n.strong,{children:"not"})," maintain subscription state. Subscriptions are sent to the broker and acknowledged, but the client does not track them. There is no ",(0,t.jsx)(n.code,{children:"client.Subscriptions"})," property and no per-subscription callbacks."]})}),"\n",(0,t.jsx)(n.h3,{id:"simple-subscribe",children:"Simple Subscribe"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Subscribe with default options (QoS 0)\nawait client.SubscribeAsync("my/topic").ConfigureAwait(false);\n\n// Subscribe with specific QoS\nawait client.SubscribeAsync("my/topic", QualityOfService.AtLeastOnceDelivery).ConfigureAwait(false);\n\n// Subscribe with additional options\nawait client.SubscribeAsync(\n    "my/topic",\n    QualityOfService.ExactlyOnceDelivery,\n    noLocal: true,\n    retainAsPublished: true,\n    retainHandling: RetainHandling.SendAtSubscribe\n).ConfigureAwait(false);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"with-subscribeoptions",children:"With SubscribeOptions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var subscribeOptions = new SubscribeOptionsBuilder()\n    .WithSubscription("topic1", QualityOfService.AtLeastOnceDelivery)\n    .WithSubscription("topic2", QualityOfService.ExactlyOnceDelivery)\n    .WithUserProperty("Client-Type", "RawClient")\n    .Build();\n\nvar result = await client.SubscribeAsync(subscribeOptions).ConfigureAwait(false);\n\n// Check results\nforeach (var subscription in result.Subscriptions)\n{\n    Console.WriteLine($"Subscribed to {subscription.TopicFilter.Topic}: {subscription.SubscribeReasonCode}");\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"receiving-messages",children:"Receiving Messages"}),"\n",(0,t.jsx)(n.h3,{id:"global-message-handler",children:"Global Message Handler"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," fires ",(0,t.jsx)(n.code,{children:"OnMessageReceived"})," for ",(0,t.jsx)(n.strong,{children:"all"})," incoming PUBLISH packets. There is no subscription matching or per-subscription routing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'client.OnMessageReceived += (sender, args) =>\n{\n    var message = args.PublishMessage;\n\n    Console.WriteLine($"Topic: {message.Topic}");\n    Console.WriteLine($"Payload: {message.PayloadAsString}");\n    Console.WriteLine($"QoS: {message.QoS}");\n    Console.WriteLine($"Retain: {message.Retain}");\n\n    // You must implement your own topic routing if needed\n    if (message.Topic.StartsWith("sensors/"))\n    {\n        HandleSensorMessage(message);\n    }\n    else if (message.Topic.StartsWith("commands/"))\n    {\n        HandleCommandMessage(message);\n    }\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementing-custom-message-routing",children:"Implementing Custom Message Routing"}),"\n",(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"RawClient"})," doesn't provide per-subscription callbacks, you can implement your own routing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Simple dictionary-based router\nvar handlers = new Dictionary<string, Action<MQTT5PublishMessage>>\n{\n    { "sensors/temperature", HandleTemperature },\n    { "sensors/humidity", HandleHumidity },\n    { "commands/restart", HandleRestart },\n};\n\nclient.OnMessageReceived += (sender, args) =>\n{\n    var message = args.PublishMessage;\n\n    if (handlers.TryGetValue(message.Topic, out var handler))\n    {\n        handler(message);\n    }\n    else\n    {\n        Console.WriteLine($"No handler for topic: {message.Topic}");\n    }\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"unsubscribing",children:"Unsubscribing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var unsubscribeOptions = new UnsubscribeOptionsBuilder()\n    .WithSubscription("topic1")\n    .WithSubscription("topic2")\n    .Build();\n\nvar result = await client.UnsubscribeAsync(unsubscribeOptions).ConfigureAwait(false);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"disconnecting",children:"Disconnecting"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Simple disconnect\nawait client.DisconnectAsync().ConfigureAwait(false);\n\n// Disconnect with options\nvar disconnectOptions = new DisconnectOptions\n{\n    ReasonCode = DisconnectReasonCode.NormalDisconnection,\n};\n\nawait client.DisconnectAsync(disconnectOptions).ConfigureAwait(false);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RawClient"})," supports the same lifecycle and packet-level events as ",(0,t.jsx)(n.code,{children:"HiveMQClient"}),":"]}),"\n",(0,t.jsx)(n.h3,{id:"lifecycle-events",children:"Lifecycle Events"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'client.BeforeConnect += (sender, args) => Console.WriteLine("About to connect...");\nclient.AfterConnect += (sender, args) => Console.WriteLine($"Connected: {args.ConnectResult.ReasonCode}");\nclient.BeforeDisconnect += (sender, args) => Console.WriteLine("About to disconnect...");\nclient.AfterDisconnect += (sender, args) => Console.WriteLine($"Disconnected (clean: {args.CleanDisconnect})");\nclient.BeforeSubscribe += (sender, args) => Console.WriteLine("About to subscribe...");\nclient.AfterSubscribe += (sender, args) => Console.WriteLine("Subscribed!");\nclient.BeforeUnsubscribe += (sender, args) => Console.WriteLine("About to unsubscribe...");\nclient.AfterUnsubscribe += (sender, args) => Console.WriteLine("Unsubscribed!");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"packet-level-events",children:"Packet-Level Events"}),"\n",(0,t.jsx)(n.p,{children:"For protocol-level debugging and monitoring:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Connection packets\nclient.OnConnectSent += (sender, args) => Console.WriteLine("CONNECT sent");\nclient.OnConnAckReceived += (sender, args) => Console.WriteLine("CONNACK received");\nclient.OnDisconnectSent += (sender, args) => Console.WriteLine("DISCONNECT sent");\nclient.OnDisconnectReceived += (sender, args) => Console.WriteLine("DISCONNECT received from broker");\n\n// Keep-alive packets\nclient.OnPingReqSent += (sender, args) => Console.WriteLine("PINGREQ sent");\nclient.OnPingRespReceived += (sender, args) => Console.WriteLine("PINGRESP received");\n\n// Subscription packets\nclient.OnSubscribeSent += (sender, args) => Console.WriteLine("SUBSCRIBE sent");\nclient.OnSubAckReceived += (sender, args) => Console.WriteLine("SUBACK received");\nclient.OnUnsubscribeSent += (sender, args) => Console.WriteLine("UNSUBSCRIBE sent");\nclient.OnUnsubAckReceived += (sender, args) => Console.WriteLine("UNSUBACK received");\n\n// Publish packets\nclient.OnPublishSent += (sender, args) => Console.WriteLine($"PUBLISH sent: {args.PublishPacket.Message.Topic}");\nclient.OnPublishReceived += (sender, args) => Console.WriteLine($"PUBLISH received: {args.PublishPacket.Message.Topic}");\n\n// QoS 1 acknowledgment\nclient.OnPubAckSent += (sender, args) => Console.WriteLine("PUBACK sent");\nclient.OnPubAckReceived += (sender, args) => Console.WriteLine("PUBACK received");\n\n// QoS 2 handshake\nclient.OnPubRecSent += (sender, args) => Console.WriteLine("PUBREC sent");\nclient.OnPubRecReceived += (sender, args) => Console.WriteLine("PUBREC received");\nclient.OnPubRelSent += (sender, args) => Console.WriteLine("PUBREL sent");\nclient.OnPubRelReceived += (sender, args) => Console.WriteLine("PUBREL received");\nclient.OnPubCompSent += (sender, args) => Console.WriteLine("PUBCOMP sent");\nclient.OnPubCompReceived += (sender, args) => Console.WriteLine("PUBCOMP received");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"localstore",children:"LocalStore"}),"\n",(0,t.jsxs)(n.p,{children:["Like ",(0,t.jsx)(n.code,{children:"HiveMQClient"}),", the ",(0,t.jsx)(n.code,{children:"RawClient"})," provides a ",(0,t.jsx)(n.code,{children:"LocalStore"})," dictionary for storing client-specific data:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Store application-specific data\nclient.LocalStore["device-id"] = "sensor-001";\nclient.LocalStore["location"] = "building-a";\n\n// Retrieve later\nvar deviceId = client.LocalStore["device-id"];\n'})}),"\n",(0,t.jsx)(n.h2,{id:"resource-cleanup",children:"Resource Cleanup"}),"\n",(0,t.jsx)(n.p,{children:"Always dispose of the client when done:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Using pattern (recommended)\nawait using var client = new RawClient(options);\nawait client.ConnectAsync();\n// ... use client ...\nawait client.DisconnectAsync();\n\n// Or explicit dispose\nvar client = new RawClient(options);\ntry\n{\n    await client.ConnectAsync();\n    // ... use client ...\n    await client.DisconnectAsync();\n}\nfinally\n{\n    client.Dispose();\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using HiveMQtt.Client;\nusing HiveMQtt.MQTT5.Types;\n\n// Configure the client\nvar options = new HiveMQClientOptionsBuilder()\n    .WithBroker("broker.hivemq.com")\n    .WithPort(1883)\n    .WithClientId("raw-client-example")\n    .Build();\n\nvar client = new RawClient(options);\n\n// Setup message handler BEFORE connecting\nclient.OnMessageReceived += (sender, args) =>\n{\n    Console.WriteLine($"[{args.PublishMessage.Topic}]: {args.PublishMessage.PayloadAsString}");\n};\n\n// Track connection state changes\nclient.AfterConnect += (sender, args) => Console.WriteLine("Connected to broker");\nclient.AfterDisconnect += (sender, args) => Console.WriteLine("Disconnected from broker");\n\ntry\n{\n    // Connect\n    var connectResult = await client.ConnectAsync().ConfigureAwait(false);\n\n    if (connectResult.ReasonCode != ConnAckReasonCode.Success)\n    {\n        Console.WriteLine($"Connection failed: {connectResult.ReasonCode}");\n        return;\n    }\n\n    // Subscribe to topics\n    await client.SubscribeAsync("test/topic1", QualityOfService.AtLeastOnceDelivery).ConfigureAwait(false);\n    await client.SubscribeAsync("test/topic2", QualityOfService.ExactlyOnceDelivery).ConfigureAwait(false);\n\n    // Publish messages\n    for (var i = 0; i < 10; i++)\n    {\n        await client.PublishAsync("test/topic1", $"Message {i}").ConfigureAwait(false);\n        await Task.Delay(100);\n    }\n\n    // Wait for messages\n    await Task.Delay(1000);\n\n    // Disconnect\n    await client.DisconnectAsync().ConfigureAwait(false);\n}\nfinally\n{\n    client.Dispose();\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/hivemq/hivemq-mqtt-client-dotnet/blob/main/Source/HiveMQtt/Client/RawClient.cs",children:"RawClient.cs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/hivemq/hivemq-mqtt-client-dotnet/blob/main/Source/HiveMQtt/Client/IRawClient.cs",children:"IRawClient.cs"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/quickstart",children:"HiveMQClient"})," - The standard client with full subscription management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/events",children:"Events"})," - Event system documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/publishing",children:"Publishing Messages"})," - Detailed publishing documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/subscribing",children:"Subscribing to Topics"})," - Detailed subscription documentation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},c=s.createContext(t);function r(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);